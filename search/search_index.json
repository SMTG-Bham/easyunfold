{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to easyunfold documentation This package is intended for obtaining the effective band structure of a supercell for a certain path of the primitive cell. It was originally based on PyVaspwfc for reading wavefunction output of VASP, and contains some code of the latter. An notable improvement is that breaking symmetry is taken accounted of by sampling additional kpoints and taking average accordingly, which was previously missing. Our goal is to make the unfolding process easier to carry out and less likely to go wrong. For the methodology, see here . Usage Main goal of this tool is to make the unfolding process easier. To generate a unfolded band structure, one typically needs to perform the following step: Create a primitive cell, and generate a k point path for this primitive cell. Create a supercell, and obtain its optimised structure. Generate a series of kpoints in the supercell to be calculated. Perform a band structure calculation using the supercell, and save its wave function. Run post-processing to obtain the unfolded band structure. The supercell usually contains certain defects, or a special quasi random structure. In both cases, its symmetry is lowered when compared to the perfect primitive cell. Hence, for a given kpoint path in the primitive cell, additional kpoints may need to be sampled, and the extracted spectral weights need to be averaged in the end to obtained the effective band structure (EBS). At the moment, only VASP calculations are supported, although in principle other PW code can be supported easily if the wavefunction can be read in. Please see the documentation for guide and examples. Studies using easyunfold We'll add papers that use easyunfold to this list as they come out! Y. T. Huang & S. R. Kavanagh et al. Nature Communications 2022 A. T. J. Nicolson et al. ChemRxiv 2023 Y. Wang & S. R. Kavanagh et al. Nature Photonics 2022 (early version) Contributors Code Contributors: Bonan Zhu Se\u00e1n Kavanagh Adair Nicolson And those who helped in the development: Joe Willis David O. Scanlon","title":"Home"},{"location":"#welcome-to-easyunfold-documentation","text":"This package is intended for obtaining the effective band structure of a supercell for a certain path of the primitive cell. It was originally based on PyVaspwfc for reading wavefunction output of VASP, and contains some code of the latter. An notable improvement is that breaking symmetry is taken accounted of by sampling additional kpoints and taking average accordingly, which was previously missing. Our goal is to make the unfolding process easier to carry out and less likely to go wrong. For the methodology, see here .","title":"Welcome to easyunfold documentation"},{"location":"#usage","text":"Main goal of this tool is to make the unfolding process easier. To generate a unfolded band structure, one typically needs to perform the following step: Create a primitive cell, and generate a k point path for this primitive cell. Create a supercell, and obtain its optimised structure. Generate a series of kpoints in the supercell to be calculated. Perform a band structure calculation using the supercell, and save its wave function. Run post-processing to obtain the unfolded band structure. The supercell usually contains certain defects, or a special quasi random structure. In both cases, its symmetry is lowered when compared to the perfect primitive cell. Hence, for a given kpoint path in the primitive cell, additional kpoints may need to be sampled, and the extracted spectral weights need to be averaged in the end to obtained the effective band structure (EBS). At the moment, only VASP calculations are supported, although in principle other PW code can be supported easily if the wavefunction can be read in. Please see the documentation for guide and examples.","title":"Usage"},{"location":"#studies-using-easyunfold","text":"We'll add papers that use easyunfold to this list as they come out! Y. T. Huang & S. R. Kavanagh et al. Nature Communications 2022 A. T. J. Nicolson et al. ChemRxiv 2023 Y. Wang & S. R. Kavanagh et al. Nature Photonics 2022 (early version)","title":"Studies using easyunfold"},{"location":"#contributors","text":"Code Contributors: Bonan Zhu Se\u00e1n Kavanagh Adair Nicolson And those who helped in the development: Joe Willis David O. Scanlon","title":"Contributors"},{"location":"cli/","text":"CLI Reference This page provides documentation for our command line tools. easyunfold Tool for performing band unfolding Usage: easyunfold [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. easyunfold generate Generate the kpoints for sampling the supercell Usage: easyunfold generate [OPTIONS] PC_FILE SC_FILE KPOINTS Options: --time-reversal / --no-time-reversal -m, --matrix TEXT Transformation matrix --symprec FLOAT Transformation matrix --out-file TEXT Name of the output file --no-expand Do not expand the kpoints by symmetry --nk-per-split INTEGER Number of band structure kpoints per split. --scf-kpoints FILE File (IBZKPT) to provide SCF kpoints for self-consistent calculations. Needed for hybrid functional calculations. --help Show this message and exit. easyunfold unfold Perform unfolding and plotting Usage: easyunfold unfold [OPTIONS] COMMAND [ARGS]... Options: --data-file FILE --help Show this message and exit. easyunfold unfold calculate Perform the unfolding Multiple WAVECAR files can be supplied for split-path calculations. Usage: easyunfold unfold calculate [OPTIONS] [WAVECAR]... Options: --save-as TEXT --gamma --ncl --help Show this message and exit. easyunfold unfold effective-mass Compute and print effective masses by tracing the unfolded weights. Note that this functionality only works for simple unfolded band structures, and it is likely to fail for complex cases. Usage: easyunfold unfold effective-mass [OPTIONS] Options: --intensity-tol FLOAT --spin INTEGER --npoints INTEGER --extrema-detect-tol FLOAT --degeneracy-detect-tol FLOAT --nocc INTEGER --plot --out-file TEXT Name of the output file. --help Show this message and exit. easyunfold unfold plot Plot the spectral function This command uses the stored unfolding data to plot the effective bands structure (EBS). Usage: easyunfold unfold plot [OPTIONS] Options: --title TEXT Title to be used --orbitals TEXT Orbitals of to be used for weighting. --atoms-idx TEXT Indices of the atoms to be used for weighting (1-indexed). --procar TEXT PROCAR files used for atomic weighting --no-symm-average Do not include symmetry related kpoints for averaging. --show Show the plot interactively. --cmap TEXT Name of the colour map(s) to use. Passing a list separated by \"|\" for the combined plot. [default: PuRd] --out-file TEXT Name of the output file. --vscale FLOAT A scaling factor for the colour mapping. --emax FLOAT Maximum energy in eV relative to the reference. [default: 5.0] --emin FLOAT Minimum energy in eV relative to the reference. [default: -5.0] --eref FLOAT Reference energy in eV. --sigma FLOAT Smearing width for the energy in eV. [default: 0.02] --npoints INTEGER Number of bins for the energy. [default: 2000] --ncl Is the calculation with non-colinear spin? --gamma Is the calculation a gamma only one? --help Show this message and exit. easyunfold unfold plot-projections Plot with subplots with multiple atomic projections Usage: easyunfold unfold plot-projections [OPTIONS] Options: --title TEXT Title to be used --orbitals TEXT Orbitals of to be used for weighting. --atoms-idx TEXT Indices of the atoms to be used for weighting (1-indexed). --procar TEXT PROCAR files used for atomic weighting --no-symm-average Do not include symmetry related kpoints for averaging. --show Show the plot interactively. --cmap TEXT Name of the colour map(s) to use. Passing a list separated by \"|\" for the combined plot. [default: PuRd] --out-file TEXT Name of the output file. --vscale FLOAT A scaling factor for the colour mapping. --emax FLOAT Maximum energy in eV relative to the reference. [default: 5.0] --emin FLOAT Minimum energy in eV relative to the reference. [default: -5.0] --eref FLOAT Reference energy in eV. --sigma FLOAT Smearing width for the energy in eV. [default: 0.02] --npoints INTEGER Number of bins for the energy. [default: 2000] --ncl Is the calculation with non-colinear spin? --gamma Is the calculation a gamma only one? --combined / --no-combined Plot all projections in a combined graph. --intensity FLOAT Color intensity for combined plot [default: 1.0] --colors TEXT Colors to be used for combined plot. Comma separated. Default = \"r,g,b\". --help Show this message and exit. easyunfold unfold status Print the status Usage: easyunfold unfold status [OPTIONS] Options: --help Show this message and exit.","title":"CLI Commands"},{"location":"cli/#cli-reference","text":"This page provides documentation for our command line tools.","title":"CLI Reference"},{"location":"cli/#easyunfold","text":"Tool for performing band unfolding Usage: easyunfold [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit.","title":"easyunfold"},{"location":"cli/#easyunfold-generate","text":"Generate the kpoints for sampling the supercell Usage: easyunfold generate [OPTIONS] PC_FILE SC_FILE KPOINTS Options: --time-reversal / --no-time-reversal -m, --matrix TEXT Transformation matrix --symprec FLOAT Transformation matrix --out-file TEXT Name of the output file --no-expand Do not expand the kpoints by symmetry --nk-per-split INTEGER Number of band structure kpoints per split. --scf-kpoints FILE File (IBZKPT) to provide SCF kpoints for self-consistent calculations. Needed for hybrid functional calculations. --help Show this message and exit.","title":"generate"},{"location":"cli/#easyunfold-unfold","text":"Perform unfolding and plotting Usage: easyunfold unfold [OPTIONS] COMMAND [ARGS]... Options: --data-file FILE --help Show this message and exit.","title":"unfold"},{"location":"cli/#easyunfold-unfold-calculate","text":"Perform the unfolding Multiple WAVECAR files can be supplied for split-path calculations. Usage: easyunfold unfold calculate [OPTIONS] [WAVECAR]... Options: --save-as TEXT --gamma --ncl --help Show this message and exit.","title":"calculate"},{"location":"cli/#easyunfold-unfold-effective-mass","text":"Compute and print effective masses by tracing the unfolded weights. Note that this functionality only works for simple unfolded band structures, and it is likely to fail for complex cases. Usage: easyunfold unfold effective-mass [OPTIONS] Options: --intensity-tol FLOAT --spin INTEGER --npoints INTEGER --extrema-detect-tol FLOAT --degeneracy-detect-tol FLOAT --nocc INTEGER --plot --out-file TEXT Name of the output file. --help Show this message and exit.","title":"effective-mass"},{"location":"cli/#easyunfold-unfold-plot","text":"Plot the spectral function This command uses the stored unfolding data to plot the effective bands structure (EBS). Usage: easyunfold unfold plot [OPTIONS] Options: --title TEXT Title to be used --orbitals TEXT Orbitals of to be used for weighting. --atoms-idx TEXT Indices of the atoms to be used for weighting (1-indexed). --procar TEXT PROCAR files used for atomic weighting --no-symm-average Do not include symmetry related kpoints for averaging. --show Show the plot interactively. --cmap TEXT Name of the colour map(s) to use. Passing a list separated by \"|\" for the combined plot. [default: PuRd] --out-file TEXT Name of the output file. --vscale FLOAT A scaling factor for the colour mapping. --emax FLOAT Maximum energy in eV relative to the reference. [default: 5.0] --emin FLOAT Minimum energy in eV relative to the reference. [default: -5.0] --eref FLOAT Reference energy in eV. --sigma FLOAT Smearing width for the energy in eV. [default: 0.02] --npoints INTEGER Number of bins for the energy. [default: 2000] --ncl Is the calculation with non-colinear spin? --gamma Is the calculation a gamma only one? --help Show this message and exit.","title":"plot"},{"location":"cli/#easyunfold-unfold-plot-projections","text":"Plot with subplots with multiple atomic projections Usage: easyunfold unfold plot-projections [OPTIONS] Options: --title TEXT Title to be used --orbitals TEXT Orbitals of to be used for weighting. --atoms-idx TEXT Indices of the atoms to be used for weighting (1-indexed). --procar TEXT PROCAR files used for atomic weighting --no-symm-average Do not include symmetry related kpoints for averaging. --show Show the plot interactively. --cmap TEXT Name of the colour map(s) to use. Passing a list separated by \"|\" for the combined plot. [default: PuRd] --out-file TEXT Name of the output file. --vscale FLOAT A scaling factor for the colour mapping. --emax FLOAT Maximum energy in eV relative to the reference. [default: 5.0] --emin FLOAT Minimum energy in eV relative to the reference. [default: -5.0] --eref FLOAT Reference energy in eV. --sigma FLOAT Smearing width for the energy in eV. [default: 0.02] --npoints INTEGER Number of bins for the energy. [default: 2000] --ncl Is the calculation with non-colinear spin? --gamma Is the calculation a gamma only one? --combined / --no-combined Plot all projections in a combined graph. --intensity FLOAT Color intensity for combined plot [default: 1.0] --colors TEXT Colors to be used for combined plot. Comma separated. Default = \"r,g,b\". --help Show this message and exit.","title":"plot-projections"},{"location":"cli/#easyunfold-unfold-status","text":"Print the status Usage: easyunfold unfold status [OPTIONS] Options: --help Show this message and exit.","title":"status"},{"location":"example_mgo/","text":"Unfolding MgO band structure with atomic projections Note Relevant files can be found in the examples/MgO folder. In some cases, it is useful to know the atomic contributions of the bands. This can be done for unfolded bands as well. For a normal band structure, the contributions can be inferred by colouring the band according to the elemental contributions. Band structure of MgO with atomic contribution Similar plots can be generate for unfolded band structure. However, because the spectral function itself contains both the location of the band and its intensity , adding a third information regarding the projection can be tricky. In this example, we unfold the bands from a MgO 2x1x2 supercell with the first Mg atom displaced. The procedure is essentially the same as the Si supercell example. The only difference is that we turn on the calculation of orbital projections with LORBIT=11 in the INCAR file. When plotting the unfolded band, the plot-projections subcommand is used: easyunfold unfold plot-projections --procar MgO_super/PROCAR \\ --atoms-idx=\"1-4|5-8\" --out-file unfold_project.png --combined --cmap=\"Greens|Reds\" Note that the path of the PROCAR is passed along with the group of atoms. In this example, the first four atoms are Mg the last four are O , and we would like to show the contribution of the band based on the elements. Different groups are separated by | , and - can be used to define the range. Note that use of one-based indexing for atoms, although in python zero-based indexing is used internally. Note The projections are not stored in the easyunfold.json data file. So the PROCAR should be kept for replotting in the future. The --combined option creates a combined plot with each group colour with different colour maps. The spectral intensity is used to define the transparency ( alpha ) allowing the fusion of multiple projections into a single plot. Unfolded MgO band structure with projections. Green for Mg atoms and red for O atoms. In some cases, especially if there are many projection to be plotted at the same time, it can be clearer to create separated plots for each. easyunfold unfold plot-projections --procar MgO_super/PROCAR --atoms-idx=\"1-4|5-8\" \\ --out-file unfold_project_sep.png Unfolded MgO band structure with projections plotted separately.","title":"MgO Projection"},{"location":"example_mgo/#unfolding-mgo-band-structure-with-atomic-projections","text":"Note Relevant files can be found in the examples/MgO folder. In some cases, it is useful to know the atomic contributions of the bands. This can be done for unfolded bands as well. For a normal band structure, the contributions can be inferred by colouring the band according to the elemental contributions. Band structure of MgO with atomic contribution Similar plots can be generate for unfolded band structure. However, because the spectral function itself contains both the location of the band and its intensity , adding a third information regarding the projection can be tricky. In this example, we unfold the bands from a MgO 2x1x2 supercell with the first Mg atom displaced. The procedure is essentially the same as the Si supercell example. The only difference is that we turn on the calculation of orbital projections with LORBIT=11 in the INCAR file. When plotting the unfolded band, the plot-projections subcommand is used: easyunfold unfold plot-projections --procar MgO_super/PROCAR \\ --atoms-idx=\"1-4|5-8\" --out-file unfold_project.png --combined --cmap=\"Greens|Reds\" Note that the path of the PROCAR is passed along with the group of atoms. In this example, the first four atoms are Mg the last four are O , and we would like to show the contribution of the band based on the elements. Different groups are separated by | , and - can be used to define the range. Note that use of one-based indexing for atoms, although in python zero-based indexing is used internally. Note The projections are not stored in the easyunfold.json data file. So the PROCAR should be kept for replotting in the future. The --combined option creates a combined plot with each group colour with different colour maps. The spectral intensity is used to define the transparency ( alpha ) allowing the fusion of multiple projections into a single plot. Unfolded MgO band structure with projections. Green for Mg atoms and red for O atoms. In some cases, especially if there are many projection to be plotted at the same time, it can be clearer to create separated plots for each. easyunfold unfold plot-projections --procar MgO_super/PROCAR --atoms-idx=\"1-4|5-8\" \\ --out-file unfold_project_sep.png Unfolded MgO band structure with projections plotted separately.","title":"Unfolding MgO band structure with atomic projections"},{"location":"example_nabis2/","text":"Unfolding the Band Structure of Cation-Disordered NaBiS 2 , with and without Atomic Projections Note Relevant files can be found in the examples/NaBiS2 folder. Note that the PROCAR.gz file will need to be decompressed with gzip -d PROCAR.gz if reproducing these example plots with the raw data. In this example, we unfold the bands from a 80-atom special-quasirandom (SQS) supercell of NaBiS \\(_2\\) , where the Na and Bi cations are quasi-randomly distributed, in order to simulate randomised cation disorder in the material. These results were published in Y. T. Huang & S. R. Kavanagh et al. Nature Communications 2022, and an early version of easyunfold was used for the similar AgBiS \\(_2\\) in Y. Wang & S. R. Kavanagh et al. Nature Photonics 2022, with these plots demonstrating the key differences in electronic structure and thus photovoltaic performance between these two materials. We have previously calculated the easyunfold.json file from the calculation using easyunfold calculate WAVECAR . Using the default plotting options with easyunfold unfold plot , we obtain the following unfolded band structure: Unfolded band structure of NaBiS 2 This is nice, but we can make the plot a little clearer by adjusting some of the parameters like the intensity scaling (via --vscale ) and the colour map (via --cmap ). Below we set --vscale 0.4 to increase the colourmap intensity, and try BuPu , viridis and bone_r from left to right below: easyunfold unfold plot --vscale 0 .4 --cmap \"BuPu\" easyunfold unfold plot --vscale 0 .4 --cmap \"viridis\" easyunfold unfold plot --vscale 0 .4 --cmap \"bone_r\" BuPu viridis bone_r We can also plot the unfolded band structure with atomic projections, which is useful for understanding the electronic structure of the material. In this case, we are curious as to which atoms are contributing to the band edges, and so the atomic projections will be useful. For this, we need the PROCAR output from VASP with the atomic and orbital projection information, and so LORBIT should be set to 11 or 12 in the INCAR for the original calculation. When plotting the unfolded band, the plot-projections subcommand is used with the --procar <PROCAR> and --atoms-idx <atoms-idx> options: easyunfold unfold plot-projections --atoms-idx = \"1-20|21-40|41-80\" --procar PROCAR --intensity = 2 --combined Unfolded band structure of NaBiS 2 with atomic contributions From this plot, we can see that Sulfur anions (in blue) dominate the valence band, while Bismuth cations (in green) dominate the conduction band, with minimal contributions from the Sodium cations as expected. Note that the path of the PROCAR is passed along with the group of atoms. In this example, the first 20 atoms are Na , the second 20 are Bi and the last 40 are S . Different groups are separated by | , and - can be used to define the range. Note that we use \"1-based indexing\" for the atoms here, matching the VASP format (i.e. the index of the first atom is 1, not zero as in python). Note The projections are not stored in the easyunfold.json data file. So the PROCAR should be kept for replotting in the future. While the main conclusions of S dominating the valence band and Bi dominating the conduction band are clear from the plot above, the high intensity of the S projections in the valence band makes the Bi contributions in the conduction band more faint and less apparent. So, we can create separated plots for each atom type to make their individual contributions more clear: easyunfold unfold plot-projections --atoms-idx=\"1-20|21-40|41-80\" --procar PROCAR --cmap=\"bone_r\" --vscale 0.4 Unfolded band structure of NaBiS 2 with atomic contributions plotted separately An alternative option here is also to just plot only the contributions of Na and Bi cations, with no S projections: easyunfold unfold plot-projections --atoms-idx = \"1-20|21-40\" --procar PROCAR --intensity = 2 --combined --colors = \"r,g\" Unfolded band structure of NaBiS 2 with atomic contributions of only Na and Bi While this plot isn't the most aesthetic, it clearly shows that Bi (green) contributes to both the conduction band and (less so) valence states, but Na (red) doesn't contribute significantly at all.","title":"NaBiS2 SQS Projection"},{"location":"example_nabis2/#unfolding-the-band-structure-of-cation-disordered-nabis2-with-and-without-atomic-projections","text":"Note Relevant files can be found in the examples/NaBiS2 folder. Note that the PROCAR.gz file will need to be decompressed with gzip -d PROCAR.gz if reproducing these example plots with the raw data. In this example, we unfold the bands from a 80-atom special-quasirandom (SQS) supercell of NaBiS \\(_2\\) , where the Na and Bi cations are quasi-randomly distributed, in order to simulate randomised cation disorder in the material. These results were published in Y. T. Huang & S. R. Kavanagh et al. Nature Communications 2022, and an early version of easyunfold was used for the similar AgBiS \\(_2\\) in Y. Wang & S. R. Kavanagh et al. Nature Photonics 2022, with these plots demonstrating the key differences in electronic structure and thus photovoltaic performance between these two materials. We have previously calculated the easyunfold.json file from the calculation using easyunfold calculate WAVECAR . Using the default plotting options with easyunfold unfold plot , we obtain the following unfolded band structure: Unfolded band structure of NaBiS 2 This is nice, but we can make the plot a little clearer by adjusting some of the parameters like the intensity scaling (via --vscale ) and the colour map (via --cmap ). Below we set --vscale 0.4 to increase the colourmap intensity, and try BuPu , viridis and bone_r from left to right below: easyunfold unfold plot --vscale 0 .4 --cmap \"BuPu\" easyunfold unfold plot --vscale 0 .4 --cmap \"viridis\" easyunfold unfold plot --vscale 0 .4 --cmap \"bone_r\" BuPu viridis bone_r We can also plot the unfolded band structure with atomic projections, which is useful for understanding the electronic structure of the material. In this case, we are curious as to which atoms are contributing to the band edges, and so the atomic projections will be useful. For this, we need the PROCAR output from VASP with the atomic and orbital projection information, and so LORBIT should be set to 11 or 12 in the INCAR for the original calculation. When plotting the unfolded band, the plot-projections subcommand is used with the --procar <PROCAR> and --atoms-idx <atoms-idx> options: easyunfold unfold plot-projections --atoms-idx = \"1-20|21-40|41-80\" --procar PROCAR --intensity = 2 --combined Unfolded band structure of NaBiS 2 with atomic contributions From this plot, we can see that Sulfur anions (in blue) dominate the valence band, while Bismuth cations (in green) dominate the conduction band, with minimal contributions from the Sodium cations as expected. Note that the path of the PROCAR is passed along with the group of atoms. In this example, the first 20 atoms are Na , the second 20 are Bi and the last 40 are S . Different groups are separated by | , and - can be used to define the range. Note that we use \"1-based indexing\" for the atoms here, matching the VASP format (i.e. the index of the first atom is 1, not zero as in python). Note The projections are not stored in the easyunfold.json data file. So the PROCAR should be kept for replotting in the future. While the main conclusions of S dominating the valence band and Bi dominating the conduction band are clear from the plot above, the high intensity of the S projections in the valence band makes the Bi contributions in the conduction band more faint and less apparent. So, we can create separated plots for each atom type to make their individual contributions more clear: easyunfold unfold plot-projections --atoms-idx=\"1-20|21-40|41-80\" --procar PROCAR --cmap=\"bone_r\" --vscale 0.4 Unfolded band structure of NaBiS 2 with atomic contributions plotted separately An alternative option here is also to just plot only the contributions of Na and Bi cations, with no S projections: easyunfold unfold plot-projections --atoms-idx = \"1-20|21-40\" --procar PROCAR --intensity = 2 --combined --colors = \"r,g\" Unfolded band structure of NaBiS 2 with atomic contributions of only Na and Bi While this plot isn't the most aesthetic, it clearly shows that Bi (green) contributes to both the conduction band and (less so) valence states, but Na (red) doesn't contribute significantly at all.","title":"Unfolding the Band Structure of Cation-Disordered NaBiS2, with and without Atomic Projections"},{"location":"example_si222/","text":"Unfolding 2x2x2 Si supercell with a displaced atom Generate project file and kpoints for supercell calculation Note The files needed as provided in expamples/Si222. This guide assumes the current working directory is located at the root of that folder. First, generate the supercell kpoints: easyunfold generate Si/POSCAR Si_super_deformed/POSCAR Si/KPOINTS_band Copy the kpoints to the supercell calculation folder: cp KPOINTS_easyunfold Si_supercell_deformed This generates an easyunfold.json file in the current direction containing information about the unfolding. Name of this file can be modified with the --out-file commandline argument. Information stored in this file can be inspected with command: $ easyunfold unfold status Loaded data from easyunfold.json Primitive cell information: Space group number: 160 Internation symbol: R3m Point group: 3m Supercell cell information: Space group number: 227 Internation symbol: Fd-3m Point group: m-3m No. of k points in the primitive cell : 73 No. of expanded kpoints to be calculated cell : 132 (136) No. of rotations in the primitive cell : 48 No. of rotations in the super cell : 6 Path in the primitive cell: \\Gamma : 1 L : 21 W : 38 X : 50 \\Gamma : 73 Please run the supercell band structure calculation and run `unfold calculate`. Performing supercell band structure calculation Band structure calculation in VASP normally involves two steps. First, a normal single point calculation is performed to obtain the charge density. Afterwards, a none self-consistent calculation is carried out to compute the eigenvalues of the kpoints along the band structure paths defined. First, ensure the kpoints for SCF is used and run the supercell calculation. The ICHARG=11 must commented out in the INCAR for the single point calculation: cd Si_supercell_deformed cp KPOINTS_scf KPOINTS sed -i 's/^ICHARG = 11/!ICHARG = 11/g' INCAR mpirun -np 4 vasp_std Now run the band structure calculation with ICHARG=11 , and the kpoints mapped to the supercell from the primitive cell path: sed -i 's/.*ICHARG = 11/ICHARG = 11/g' INCAR cp KPOINTS_easyunfold KPOINTS mpirun -np 4 vasp_std Perform unfolding Calculate the weights and record the VBM: cd ../ easyunfold unfold calculate Si_super_deformed/WAVECAR Note If you don't wnat to run the VASP calculation by yourself, the calculated WAVECAR and vasprun.xml for this example with: wget -o Si_super_deformed/WAVECAR https://www.dropbox.com/s/3cmn2epw7d290jd/WAVECAR?dl=1 wget -o Si_super_deformed/vasprun.xml https://www.dropbox.com/s/ota78qqdvxsehmi/vasprun.xml?dl=1 Plot the unfolded band structure: easyunfold unfold plot Output: Spectral function of the unfolded bands Band structure of the primitive cell: Primitive cell band structure of Si Note the appearance of extra branches due to symmetry breaking. What happens if the symmetry is not taken into account? We can create a new unfolding project (data file) using the following command: easyunfold generate Si/POSCAR Si_super_deformed/POSCAR Si/KPOINTS_band --no-expand --out-file no-expand.json Swap the KPOINTS to the new file cp KPOINTS_no-expand Si_super_deformed/KPOINTS cd Si_super_deformed mpirun -np 4 vasp_std cd ../ easyunfold --help no-expand.json calculate Si_super_deformed/WAVECAR easyunfold unfold --data-file no-expand.json plot --out-file unfold_no-expand.png output: Spectral function of the unfolded bands Comparing with the one above, there are breaking of the bands and some branches are missing (near the gamma point). Nevertheless, by not expanding the kpoint paths, fewer supercell kpoints need to be calculated. $ easyunfold unfold --data-file no-expand.json plot --out-file unfold_no-expand.png Loaded data from no-expand.json Using a reference energy of 5.284 eV Unfolded band structure saved to unfold_no-expand.png $ easyunfold unfold --data-file no-expand.json status Loaded data from no-expand.json Primitive cell information: Space group number: 160 Internation symbol: R3m Point group: 3m Supercell cell information: Space group number: 227 Internation symbol: Fd-3m Point group: m-3m No. of k points in the primitive cell : 73 No. of expanded kpoints to be calculated cell : 70 (73) No. of rotations in the primitive cell : 48 No. of rotations in the super cell : 6 Path in the primitive cell: \\Gamma : 1 L : 21 W : 38 X : 50 \\Gamma : 73 Unfolding had been performed - use `unfold plot` to plot the spectral function.","title":"Si Supercell"},{"location":"example_si222/#unfolding-2x2x2-si-supercell-with-a-displaced-atom","text":"","title":"Unfolding 2x2x2 Si supercell with a displaced atom"},{"location":"example_si222/#generate-project-file-and-kpoints-for-supercell-calculation","text":"Note The files needed as provided in expamples/Si222. This guide assumes the current working directory is located at the root of that folder. First, generate the supercell kpoints: easyunfold generate Si/POSCAR Si_super_deformed/POSCAR Si/KPOINTS_band Copy the kpoints to the supercell calculation folder: cp KPOINTS_easyunfold Si_supercell_deformed This generates an easyunfold.json file in the current direction containing information about the unfolding. Name of this file can be modified with the --out-file commandline argument. Information stored in this file can be inspected with command: $ easyunfold unfold status Loaded data from easyunfold.json Primitive cell information: Space group number: 160 Internation symbol: R3m Point group: 3m Supercell cell information: Space group number: 227 Internation symbol: Fd-3m Point group: m-3m No. of k points in the primitive cell : 73 No. of expanded kpoints to be calculated cell : 132 (136) No. of rotations in the primitive cell : 48 No. of rotations in the super cell : 6 Path in the primitive cell: \\Gamma : 1 L : 21 W : 38 X : 50 \\Gamma : 73 Please run the supercell band structure calculation and run `unfold calculate`.","title":"Generate project file and kpoints for supercell calculation"},{"location":"example_si222/#performing-supercell-band-structure-calculation","text":"Band structure calculation in VASP normally involves two steps. First, a normal single point calculation is performed to obtain the charge density. Afterwards, a none self-consistent calculation is carried out to compute the eigenvalues of the kpoints along the band structure paths defined. First, ensure the kpoints for SCF is used and run the supercell calculation. The ICHARG=11 must commented out in the INCAR for the single point calculation: cd Si_supercell_deformed cp KPOINTS_scf KPOINTS sed -i 's/^ICHARG = 11/!ICHARG = 11/g' INCAR mpirun -np 4 vasp_std Now run the band structure calculation with ICHARG=11 , and the kpoints mapped to the supercell from the primitive cell path: sed -i 's/.*ICHARG = 11/ICHARG = 11/g' INCAR cp KPOINTS_easyunfold KPOINTS mpirun -np 4 vasp_std","title":"Performing supercell band structure calculation"},{"location":"example_si222/#perform-unfolding","text":"Calculate the weights and record the VBM: cd ../ easyunfold unfold calculate Si_super_deformed/WAVECAR Note If you don't wnat to run the VASP calculation by yourself, the calculated WAVECAR and vasprun.xml for this example with: wget -o Si_super_deformed/WAVECAR https://www.dropbox.com/s/3cmn2epw7d290jd/WAVECAR?dl=1 wget -o Si_super_deformed/vasprun.xml https://www.dropbox.com/s/ota78qqdvxsehmi/vasprun.xml?dl=1 Plot the unfolded band structure: easyunfold unfold plot Output: Spectral function of the unfolded bands Band structure of the primitive cell: Primitive cell band structure of Si Note the appearance of extra branches due to symmetry breaking.","title":"Perform unfolding"},{"location":"example_si222/#what-happens-if-the-symmetry-is-not-taken-into-account","text":"We can create a new unfolding project (data file) using the following command: easyunfold generate Si/POSCAR Si_super_deformed/POSCAR Si/KPOINTS_band --no-expand --out-file no-expand.json Swap the KPOINTS to the new file cp KPOINTS_no-expand Si_super_deformed/KPOINTS cd Si_super_deformed mpirun -np 4 vasp_std cd ../ easyunfold --help no-expand.json calculate Si_super_deformed/WAVECAR easyunfold unfold --data-file no-expand.json plot --out-file unfold_no-expand.png output: Spectral function of the unfolded bands Comparing with the one above, there are breaking of the bands and some branches are missing (near the gamma point). Nevertheless, by not expanding the kpoint paths, fewer supercell kpoints need to be calculated. $ easyunfold unfold --data-file no-expand.json plot --out-file unfold_no-expand.png Loaded data from no-expand.json Using a reference energy of 5.284 eV Unfolded band structure saved to unfold_no-expand.png $ easyunfold unfold --data-file no-expand.json status Loaded data from no-expand.json Primitive cell information: Space group number: 160 Internation symbol: R3m Point group: 3m Supercell cell information: Space group number: 227 Internation symbol: Fd-3m Point group: m-3m No. of k points in the primitive cell : 73 No. of expanded kpoints to be calculated cell : 70 (73) No. of rotations in the primitive cell : 48 No. of rotations in the super cell : 6 Path in the primitive cell: \\Gamma : 1 L : 21 W : 38 X : 50 \\Gamma : 73 Unfolding had been performed - use `unfold plot` to plot the spectral function.","title":"What happens if the symmetry is not taken into account?"},{"location":"guide/","text":"Main goal of this tool is to make the unfolding process easier. To generate a unfolded band structure, one typically needs to perform the following step: Create a primitive cell, and generate a k point path for this primitive cell. Create a supercell, and obtain its optimised structure. Generate a series of kpoints in the supercell to be calculated. Perform a band structure calculation using the supercell, and save its wave function. Run post-processing to obtain the unfolded band structure. The supercell usually contains certain defects, or a special quasi random structure. In both cases, its symmetry is lowered when compared to the perfect primitive cell. Hence, for a given kpoint path in the primitive cell, additional kpoints may need to be sampled, and the extracted spectral weights need to be averaged in the end to obtained the effective band structure (EBS). Step-by-step instructions At the moment, only VASP calculations are supported, although in principle other PW code can be supported easily if the wavefunction can be read in. Use of VASP is assumed for the guide below. Step 1 - Generate the kpoints path of the primitive cell This can be done by well established packages such as seekpath . Be careful that the \"standardised\" primitive cell may be different from input structure, and the generated path is correct for the standard primitive cell only. We recommand using sumo for generating the kpoints, which provides a nice command line interface: sumo-kgen -p POSCAR Care should be taken if one uses the initial structure for further supercell generation, do verify that the lattice parameters are identical between the two. A POSCAR_prim file will be written out if sumo think the primitive cell is different from the input structure. The kpoints along the path is written to KPOINTS_band . Step 2 - Generate the kpoints to be used for the supercell calculation At this point, you should have your relaxed supercell structure (which may have a lower symmetry). The set of kpoints for the supercell band structure can be generated with: easyunfold generate primitive/POSCAR supercell/POSCAR primitive/KPOINTS_band --matrix \"2 2 2\" for hybrid functional calculations, it an be useful to split the kpoints into multiple calculations for reduced costs or memory consumptions. Note that the --matrix input is for setting the transformation matrix such that cell_super = M @ cell_primitive where cell_super and cell_primitive are (3,3) matrix made of row vectors . If M is non-diagonal, all nine elements must be passed in a row-major order. It is possible to omit `--matrix`` if the supercell is perfectly commensurate with the primitive cell. This can be the case if the supercell calculation did not undergo cell relaxation. If cell relaxation did take place, it is important to note that the unfolded band structure is not for exact original primitive cell, but for a primitive cell deformed in a similar way as the supercell. A easyunfold.json file will be written which contains the information of the unfolding. The kpoints needed to be calculated for the supercell is written to a file named KPOINTS_easyunfold . It is possible to change the name easyunfold by passing a explicit tag with the command line --out-file . For hybrid functional calculations, you may want to split the kpoints into multiple calculations: easyunfold generate primitive/POSCAR supercell/POSCAR primitive/KPOINTS_band --matrix \"2 2 2\" --scf-kpoints IBZKPT --nk-per-split 60 This will generate files named as KPOINTS_easyunfold_001 , KPOINTS_easyunfold_002 , each containing 60 kpoints. If a IBZKPT file is the provided, its kpoints will be included with their original weights, and all of the kpoints included by easyunfold will be zero-weighted. This is necessary for hybrid functional calculations where the electronic minimisation must be conducted self-consistently (e.g. ICHARG<10 ). Step 3 - Perform the unfolding At this point, a supercell calculation should be completed with a WAVECAR written containing all of the kpoints in the KPOINTS_easyunfold file generated. This is typically a non self-consistent calculation with ICHARG=11 for standard DFT, or a self-consistent calculation with zero-weighted kpoints if hybrid functional is used. To compute the spectral weights, run the following command: easyunfold unfold calculate WAVECAR This command compute the spectral weight and save them into the easyunfold.json file. You can load the easyunfold.json file to read the spectral weights manually, or proceed with the command line interface to generate a plot. If the kpoints has been split into multiple calculations (for example, for those involving hybrid functional), all of the WAVECAR files need to be passed: easyunfold unfold calculate calc1/WAVECAR calc2/WAVECAR For large WAVECAR , it may take some time to parse and compute the weights. Step 4 - Plot the results Simply do: easyunfold unfold plot to generate a plot of the spectral function. It is possible to further customise the plot though command line arguments - see the help with easyunfold unfold plot --help .","title":"Guide"},{"location":"guide/#step-by-step-instructions","text":"At the moment, only VASP calculations are supported, although in principle other PW code can be supported easily if the wavefunction can be read in. Use of VASP is assumed for the guide below.","title":"Step-by-step instructions"},{"location":"guide/#step-1-generate-the-kpoints-path-of-the-primitive-cell","text":"This can be done by well established packages such as seekpath . Be careful that the \"standardised\" primitive cell may be different from input structure, and the generated path is correct for the standard primitive cell only. We recommand using sumo for generating the kpoints, which provides a nice command line interface: sumo-kgen -p POSCAR Care should be taken if one uses the initial structure for further supercell generation, do verify that the lattice parameters are identical between the two. A POSCAR_prim file will be written out if sumo think the primitive cell is different from the input structure. The kpoints along the path is written to KPOINTS_band .","title":"Step 1 - Generate the kpoints path of the primitive cell"},{"location":"guide/#step-2-generate-the-kpoints-to-be-used-for-the-supercell-calculation","text":"At this point, you should have your relaxed supercell structure (which may have a lower symmetry). The set of kpoints for the supercell band structure can be generated with: easyunfold generate primitive/POSCAR supercell/POSCAR primitive/KPOINTS_band --matrix \"2 2 2\" for hybrid functional calculations, it an be useful to split the kpoints into multiple calculations for reduced costs or memory consumptions. Note that the --matrix input is for setting the transformation matrix such that cell_super = M @ cell_primitive where cell_super and cell_primitive are (3,3) matrix made of row vectors . If M is non-diagonal, all nine elements must be passed in a row-major order. It is possible to omit `--matrix`` if the supercell is perfectly commensurate with the primitive cell. This can be the case if the supercell calculation did not undergo cell relaxation. If cell relaxation did take place, it is important to note that the unfolded band structure is not for exact original primitive cell, but for a primitive cell deformed in a similar way as the supercell. A easyunfold.json file will be written which contains the information of the unfolding. The kpoints needed to be calculated for the supercell is written to a file named KPOINTS_easyunfold . It is possible to change the name easyunfold by passing a explicit tag with the command line --out-file . For hybrid functional calculations, you may want to split the kpoints into multiple calculations: easyunfold generate primitive/POSCAR supercell/POSCAR primitive/KPOINTS_band --matrix \"2 2 2\" --scf-kpoints IBZKPT --nk-per-split 60 This will generate files named as KPOINTS_easyunfold_001 , KPOINTS_easyunfold_002 , each containing 60 kpoints. If a IBZKPT file is the provided, its kpoints will be included with their original weights, and all of the kpoints included by easyunfold will be zero-weighted. This is necessary for hybrid functional calculations where the electronic minimisation must be conducted self-consistently (e.g. ICHARG<10 ).","title":"Step 2 - Generate the kpoints to be used for the supercell calculation"},{"location":"guide/#step-3-perform-the-unfolding","text":"At this point, a supercell calculation should be completed with a WAVECAR written containing all of the kpoints in the KPOINTS_easyunfold file generated. This is typically a non self-consistent calculation with ICHARG=11 for standard DFT, or a self-consistent calculation with zero-weighted kpoints if hybrid functional is used. To compute the spectral weights, run the following command: easyunfold unfold calculate WAVECAR This command compute the spectral weight and save them into the easyunfold.json file. You can load the easyunfold.json file to read the spectral weights manually, or proceed with the command line interface to generate a plot. If the kpoints has been split into multiple calculations (for example, for those involving hybrid functional), all of the WAVECAR files need to be passed: easyunfold unfold calculate calc1/WAVECAR calc2/WAVECAR For large WAVECAR , it may take some time to parse and compute the weights.","title":"Step 3 - Perform the unfolding"},{"location":"guide/#step-4-plot-the-results","text":"Simply do: easyunfold unfold plot to generate a plot of the spectral function. It is possible to further customise the plot though command line arguments - see the help with easyunfold unfold plot --help .","title":"Step 4 - Plot the results"},{"location":"installation/","text":"At the moment, the package should be installed from the git repository. A recently version of pip is needed to do this, due to the use of new style pyproject.toml configuration file. To upgrade your pip , do: pip install -U pip Assuming the package is in the easyunfold folder, use the following command to install: pip install ./easyunfold After installation, run easyunfold should give the following output: Usage: easyunfold [OPTIONS] COMMAND [ARGS]... Tool for performing band unfolding Options: --help Show this message and exit. Commands: generate Generate the kpoints for sampling the supercell unfold Perform unfolding and plotting","title":"Installation"},{"location":"theory/","text":"Theory of unfolding Notation: \\(\\vec{k}\\) is the kpoint of the supercell and \\(\\vec{k}\\) is that of the primitive cell. Reference: https://link.aps.org/doi/10.1103/PhysRevB.85.085201 Each \\(k\\) in the primitive cell can be mapped to that in the supercell where: \\[ \\vec{K} = \\vec{k} - \\vec{G}_0. \\] with \\(\\vec{G}_0\\) being an reciprocal lattice vector. Naturally, each \\(\\vec{K}\\) in the supercell can be unfolded into a set of \\(\\vec{k}_i\\) : \\[ \\vec{k_i} = \\vec{K} + \\vec{G}_i, i=1,...,N_\\vec{K}. \\] The key implication is that for a given \\(\\vec{k}\\) , there is a unique \\(\\vec{K}\\) that it folds to. The goal of the band folding procedure is to obtain the \\(E(\\vec{k})\\) from the complicated \\(E(\\vec{K})\\) , where E is the energy of the Kohn-Sham states. This can be achieved by projecting \\(\\ket{\\vec{K}m}\\) on all of the primitive cell Block states \\(\\ket{\\vec{k}_i}\\) of a set of \\(\\vec{k_i}\\) and compute the spectral weight: \\[ P_{\\vec{K}m}(\\vec{k}_i) = \\sum_n |\\braket{\\vec{K}m |\\vec{k}_i n}|^2. \\] where \\(P\\) represents the probability of finding a set of primitive cell stats \\(\\ket{\\vec{k}_in}\\) contributing to the supercell state \\(\\ket{\\vec{K}m}\\) , or the amount of Bloch character \\(\\vec{k}_i\\) preserved in \\(\\ket{\\vec{K}m}\\) at the same energy. Based on this, one can further dervice the spectral function of \\(E\\) : \\[ A(\\vec{k}_i, E) = \\sum_m P_{\\vec{K}m}(\\vec{k}_i)\\delta(E_m - E). \\] In practice, the \\(\\delta\\) function is replaced with a Gaussian or Lorentzian function to smear the contribution with discretised \\(E\\) . Hence, the central quantity to be calculated is the \\(P_{\\vec{K}m}(\\vec{k}_i)\\) . For plane-wave basis, it can shown that (equation 15 in Popescu et al.): \\[ P_{\\vec{K}m}(\\vec{k}_j) = \\sum_{\\vec{g}} |C_{\\vec{Km}}(\\vec{g} + \\vec{G_j})|^2, \\] where \\(C_{\\vec{Km}}(\\vec{g} + \\vec{G_j})\\) the plane wave coefficients of the supercell. Symmetry considerations In practice, the set of primitive cell kpoints \\(\\vec{k}_i\\) is taken from a given path in the Brouline zone going through multiple high symmetry points. This selection of the path depends on the space group of the primitive cell. Only a limited set of paths are needed because of the presence of point group symmetry, as symmetrically equivalent kpoints contains the same eigenstates. However, the supercell to be unfolded often contains reduced point group symmetry compared to that of the primitive cell due to imperfections (presence of defects, strain, distorations e.t.c). This broken symmetry means that previously equivalent kpoints are no longer equivalent. We account of this by including images of the primitive kpoints that are no longer equivalent under the point group of that of the supercell. Weighted contributions of these extra kpoints are added to the spectral function.","title":"Theory"},{"location":"theory/#theory-of-unfolding","text":"Notation: \\(\\vec{k}\\) is the kpoint of the supercell and \\(\\vec{k}\\) is that of the primitive cell. Reference: https://link.aps.org/doi/10.1103/PhysRevB.85.085201 Each \\(k\\) in the primitive cell can be mapped to that in the supercell where: \\[ \\vec{K} = \\vec{k} - \\vec{G}_0. \\] with \\(\\vec{G}_0\\) being an reciprocal lattice vector. Naturally, each \\(\\vec{K}\\) in the supercell can be unfolded into a set of \\(\\vec{k}_i\\) : \\[ \\vec{k_i} = \\vec{K} + \\vec{G}_i, i=1,...,N_\\vec{K}. \\] The key implication is that for a given \\(\\vec{k}\\) , there is a unique \\(\\vec{K}\\) that it folds to. The goal of the band folding procedure is to obtain the \\(E(\\vec{k})\\) from the complicated \\(E(\\vec{K})\\) , where E is the energy of the Kohn-Sham states. This can be achieved by projecting \\(\\ket{\\vec{K}m}\\) on all of the primitive cell Block states \\(\\ket{\\vec{k}_i}\\) of a set of \\(\\vec{k_i}\\) and compute the spectral weight: \\[ P_{\\vec{K}m}(\\vec{k}_i) = \\sum_n |\\braket{\\vec{K}m |\\vec{k}_i n}|^2. \\] where \\(P\\) represents the probability of finding a set of primitive cell stats \\(\\ket{\\vec{k}_in}\\) contributing to the supercell state \\(\\ket{\\vec{K}m}\\) , or the amount of Bloch character \\(\\vec{k}_i\\) preserved in \\(\\ket{\\vec{K}m}\\) at the same energy. Based on this, one can further dervice the spectral function of \\(E\\) : \\[ A(\\vec{k}_i, E) = \\sum_m P_{\\vec{K}m}(\\vec{k}_i)\\delta(E_m - E). \\] In practice, the \\(\\delta\\) function is replaced with a Gaussian or Lorentzian function to smear the contribution with discretised \\(E\\) . Hence, the central quantity to be calculated is the \\(P_{\\vec{K}m}(\\vec{k}_i)\\) . For plane-wave basis, it can shown that (equation 15 in Popescu et al.): \\[ P_{\\vec{K}m}(\\vec{k}_j) = \\sum_{\\vec{g}} |C_{\\vec{Km}}(\\vec{g} + \\vec{G_j})|^2, \\] where \\(C_{\\vec{Km}}(\\vec{g} + \\vec{G_j})\\) the plane wave coefficients of the supercell.","title":"Theory of unfolding"},{"location":"theory/#symmetry-considerations","text":"In practice, the set of primitive cell kpoints \\(\\vec{k}_i\\) is taken from a given path in the Brouline zone going through multiple high symmetry points. This selection of the path depends on the space group of the primitive cell. Only a limited set of paths are needed because of the presence of point group symmetry, as symmetrically equivalent kpoints contains the same eigenstates. However, the supercell to be unfolded often contains reduced point group symmetry compared to that of the primitive cell due to imperfections (presence of defects, strain, distorations e.t.c). This broken symmetry means that previously equivalent kpoints are no longer equivalent. We account of this by including images of the primitive kpoints that are no longer equivalent under the point group of that of the supercell. Weighted contributions of these extra kpoints are added to the spectral function.","title":"Symmetry considerations"},{"location":"sources/modules/easyunfold/effective_mass/","text":"EffectiveMass EffectiveMass ( unfold : UnfoldKSet , intensity_tol = 0.1 , extrema_tol = 0.001 , degeneracy_tol = 0.01 , parabolic = True ) Calculate effective mass from unfolding data Methods: .set_nocc . set_nocc ( nocc ) .kpoints . kpoints () .kpoints_labels . kpoints_labels () .get_band_extrema . get_band_extrema ( mode : str = 'cbm' , extrema_tol : float = None , degeneracy_tol : float = None , ispin = 0 ) Obtain the kpoint idx of band maximum, sub indices in th set and the band indices. The search takes two steps, first the kpoints at the band extrema is located by comparing the band energies with that recorded in supplied cbm and vbm , based on the exgtrema_tol . Afterwards, the band indices are selected at the these kpoints using degeneracy_tol . Returns A tuple of extrema locations including a list of kpoint indices, sub-indices within the set and the band indices at each kpoint that is within the tol set. .get_effective_masses . get_effective_masses ( npoints = 3 , ispin = 0 ) Workout the effective masses based on the unfolded band structure fit_effective_mass . fit_effective_mass ( distances , energies , parabolic = True ) Fit the effective masses using either a parabolic or nonparabolic fit. Adapted from sumo . Args distances (:obj: numpy.ndarray ) : The x-distances between k-points in reciprocal Angstroms, normalised to the band extrema. energies (:obj: numpy.ndarray ) : The band eigenvalues normalised to the eigenvalue of the band extrema. parabolic (:obj: bool , optional) : Use a parabolic fit of the band edges. If False then nonparabolic fitting will be attempted. Defaults to True . Returns float : The effective mass in units of electron rest mass, :math: m_0 . points_with_tol . points_with_tol ( array , value , tol = 0.0001 ) Return the indices and values of points in an array close to the value with a tolerance","title":"easyunfold.effective_mass"},{"location":"sources/modules/easyunfold/effective_mass/#_1","text":"","title":""},{"location":"sources/modules/easyunfold/effective_mass/#effectivemass","text":"EffectiveMass ( unfold : UnfoldKSet , intensity_tol = 0.1 , extrema_tol = 0.001 , degeneracy_tol = 0.01 , parabolic = True ) Calculate effective mass from unfolding data Methods:","title":"EffectiveMass"},{"location":"sources/modules/easyunfold/effective_mass/#set_nocc","text":". set_nocc ( nocc )","title":".set_nocc"},{"location":"sources/modules/easyunfold/effective_mass/#kpoints","text":". kpoints ()","title":".kpoints"},{"location":"sources/modules/easyunfold/effective_mass/#kpoints_labels","text":". kpoints_labels ()","title":".kpoints_labels"},{"location":"sources/modules/easyunfold/effective_mass/#get_band_extrema","text":". get_band_extrema ( mode : str = 'cbm' , extrema_tol : float = None , degeneracy_tol : float = None , ispin = 0 ) Obtain the kpoint idx of band maximum, sub indices in th set and the band indices. The search takes two steps, first the kpoints at the band extrema is located by comparing the band energies with that recorded in supplied cbm and vbm , based on the exgtrema_tol . Afterwards, the band indices are selected at the these kpoints using degeneracy_tol . Returns A tuple of extrema locations including a list of kpoint indices, sub-indices within the set and the band indices at each kpoint that is within the tol set.","title":".get_band_extrema"},{"location":"sources/modules/easyunfold/effective_mass/#get_effective_masses","text":". get_effective_masses ( npoints = 3 , ispin = 0 ) Workout the effective masses based on the unfolded band structure","title":".get_effective_masses"},{"location":"sources/modules/easyunfold/effective_mass/#fit_effective_mass","text":". fit_effective_mass ( distances , energies , parabolic = True ) Fit the effective masses using either a parabolic or nonparabolic fit. Adapted from sumo . Args distances (:obj: numpy.ndarray ) : The x-distances between k-points in reciprocal Angstroms, normalised to the band extrema. energies (:obj: numpy.ndarray ) : The band eigenvalues normalised to the eigenvalue of the band extrema. parabolic (:obj: bool , optional) : Use a parabolic fit of the band edges. If False then nonparabolic fitting will be attempted. Defaults to True . Returns float : The effective mass in units of electron rest mass, :math: m_0 .","title":"fit_effective_mass"},{"location":"sources/modules/easyunfold/effective_mass/#points_with_tol","text":". points_with_tol ( array , value , tol = 0.0001 ) Return the indices and values of points in an array close to the value with a tolerance","title":"points_with_tol"},{"location":"sources/modules/easyunfold/plotting/","text":"UnfoldPlotter UnfoldPlotter ( unfold : UnfoldKSet ) A collection plotting tools for unfolded band structures Methods: .plot_spectral_function . plot_spectral_function ( engs , sf , eref = None , figsize = ( 4 , 3 ), ylim = ( - 3 , 3 ), dpi = 150 , vscale = 1.0 , contour_plot = False , alpha = 1.0 , save = False , ax = None , vmin = None , vmax = None , cmap = 'PuRd' , show = False , title = None ) Plot spectral function. Args engs (numpy.ndarray) : The energies of the spectral functions. sf (np.ndarray) : An array of the spectral function. eref (float) : Reference energy to be used - this energy will be set as zero. figsize : Size of the figure. ylim : Plotting limit for the y-axis, with respect to eref . dpi : DPI of the generated graph. vscale : A scaling factor for the colour map. contour_plot (bool) : Whether to use contour plot instead of normal meshed color map. alpha (float) : Alpha for the color map. save (str) : Name of the file where the generated figure is saved. ax : An existing plotting axis to be be used. vmin (float) : Minimum value for the color map. vmax (float) : Maximum value for the color map. cmap (str) : Name of the color map to be used. Returns The figure generated containing the spectral function. .plot_spectral_function_rgba . plot_spectral_function_rgba ( engs , sf , eref = None , figsize = ( 4 , 3 ), ylim = ( - 3 , 3 ), dpi = 150 , intensity = 1.0 , save = False , ax = None , show = False , title = None , vmin = None , vmax = None ) Plot spectral function. Args engs (numpy.ndarray) : The energies of the spectral functions. sf (np.ndarray) : An array of the spectral function. eref (float) : Reference energy to be used - this energy will be set as zero. figsize : Size of the figure. ylim : Plotting limit for the y-axis, with respect to eref . dpi : DPI of the generated graph. vscale : A scaling factor for the colour map. contour_plot (bool) : Whether to use contour plot instead of normal meshed color map. alpha (float) : Alpha for the color map. save (str) : Name of the file where the generated figure is saved. ax : An existing plotting axis to be be used. vmin (float) : Minimum value for the color map. vmax (float) : Maximum value for the color map. cmap (str) : Name of the color map to be used. Returns The figure generated containing the spectral function. .plot_effective_mass . plot_effective_mass ( eff : EffectiveMass , engs , sf , eref = None , save = None , show = False , effective_mass_data = None , ** kwargs ) Plot the effective masses on top of the spectral function. Args eff : An EffectiveMass object used for plotting. engs (numpy.ndarray) : The energies of the spectral functions. sf (np.ndarray) : An array of the spectral function. eref (float) : Reference energy to be used - this energy will be set as zero. kwargs : Other keyword arguments supplied to plot_spectral_function . Returns A figure with the data used for fitting effective mass plotted on top of the spectral function. .plot_spectral_weights . plot_spectral_weights ( figsize = ( 4 , 3 ), ylim = ( - 3 , 3 ), dpi = 150 , factor = 3.0 , eref = None , color = 'C1' , alpha = 0.5 , save = None , ax = None , show = False , title = None ) Plot the spectral weights. Note The reduction of symmetry means there can be multiple supercell kpoints for each primitive cell kpoint. When using this scattering plot representation, the markers can overlap each other leading to misrepresentations of the actual effective band structure. However, this function is still useful when: 1. the symmetry splitting is turned off. 2. direct visualization of the underlying spectral weight is needed. 3. Check the correctness of effective mass extraction. Args eref (float) : Reference energy to be used - this energy will be set as zero. figsize : Size of the figure. ylim : Plotting limit for the y-axis, with respect to eref . dpi : DPI of the generated graph. alpha (float) : Alpha for the markers. save (str) : Name of the file where the generated figure is saved. ax : Existing plotting axes to be be used (list if having two spin channels). factor (float) : Scaling factor for the marker size. color (str) : Color of the markers. Returns A Figure with the spectral weights plotted as a scatter plot. .plot_projected . plot_projected ( procar , eref = None , gamma = False , npoints = 2000 , sigma = 0.2 , ncl = False , symm_average = True , figsize = ( 4 , 3 ), ylim = ( - 3 , 3 ), dpi = 150 , vscale = 1.0 , contour_plot = False , alpha = 1.0 , save = False , ax = None , vmin = None , vmax = None , cmap = 'PuRd' , show = False , title = None , atoms_idx = None , orbitals = None , intensity = 1.0 , use_subplot = False , colors = None , colorspace = 'lab' ) Plot projected sepctral function onto multiple subplots or a single plot with colormapping. This simply computes the spectral function at each orbital/atoms sites and plot them onto multiple subplots. The columns are for each orbital and the rows are for each spin channel. interpolate_colors . interpolate_colors ( colors , weights , colorspace = 'lab' , normalize = True ) Interpolate colors at a number of points within a colorspace. Args colors (str) : A list of colors specified in any way supported by matplotlib. weights (list) : A list of weights with the shape (n, N). Where the N values of the last axis give the amount of N colors supplied in colors . colorspace (str) : The colorspace in which to perform the interpolation. The allowed values are rgb, hsv, lab, luvlc, lablch, and xyz. Returns A list of colors, specified in the rgb format as a (n, 3) array. process_projection_options . process_projection_options ( atoms_idx , orbitals ) Process commandline type specifications","title":"easyunfold.plotting"},{"location":"sources/modules/easyunfold/plotting/#_1","text":"","title":""},{"location":"sources/modules/easyunfold/plotting/#unfoldplotter","text":"UnfoldPlotter ( unfold : UnfoldKSet ) A collection plotting tools for unfolded band structures Methods:","title":"UnfoldPlotter"},{"location":"sources/modules/easyunfold/plotting/#plot_spectral_function","text":". plot_spectral_function ( engs , sf , eref = None , figsize = ( 4 , 3 ), ylim = ( - 3 , 3 ), dpi = 150 , vscale = 1.0 , contour_plot = False , alpha = 1.0 , save = False , ax = None , vmin = None , vmax = None , cmap = 'PuRd' , show = False , title = None ) Plot spectral function. Args engs (numpy.ndarray) : The energies of the spectral functions. sf (np.ndarray) : An array of the spectral function. eref (float) : Reference energy to be used - this energy will be set as zero. figsize : Size of the figure. ylim : Plotting limit for the y-axis, with respect to eref . dpi : DPI of the generated graph. vscale : A scaling factor for the colour map. contour_plot (bool) : Whether to use contour plot instead of normal meshed color map. alpha (float) : Alpha for the color map. save (str) : Name of the file where the generated figure is saved. ax : An existing plotting axis to be be used. vmin (float) : Minimum value for the color map. vmax (float) : Maximum value for the color map. cmap (str) : Name of the color map to be used. Returns The figure generated containing the spectral function.","title":".plot_spectral_function"},{"location":"sources/modules/easyunfold/plotting/#plot_spectral_function_rgba","text":". plot_spectral_function_rgba ( engs , sf , eref = None , figsize = ( 4 , 3 ), ylim = ( - 3 , 3 ), dpi = 150 , intensity = 1.0 , save = False , ax = None , show = False , title = None , vmin = None , vmax = None ) Plot spectral function. Args engs (numpy.ndarray) : The energies of the spectral functions. sf (np.ndarray) : An array of the spectral function. eref (float) : Reference energy to be used - this energy will be set as zero. figsize : Size of the figure. ylim : Plotting limit for the y-axis, with respect to eref . dpi : DPI of the generated graph. vscale : A scaling factor for the colour map. contour_plot (bool) : Whether to use contour plot instead of normal meshed color map. alpha (float) : Alpha for the color map. save (str) : Name of the file where the generated figure is saved. ax : An existing plotting axis to be be used. vmin (float) : Minimum value for the color map. vmax (float) : Maximum value for the color map. cmap (str) : Name of the color map to be used. Returns The figure generated containing the spectral function.","title":".plot_spectral_function_rgba"},{"location":"sources/modules/easyunfold/plotting/#plot_effective_mass","text":". plot_effective_mass ( eff : EffectiveMass , engs , sf , eref = None , save = None , show = False , effective_mass_data = None , ** kwargs ) Plot the effective masses on top of the spectral function. Args eff : An EffectiveMass object used for plotting. engs (numpy.ndarray) : The energies of the spectral functions. sf (np.ndarray) : An array of the spectral function. eref (float) : Reference energy to be used - this energy will be set as zero. kwargs : Other keyword arguments supplied to plot_spectral_function . Returns A figure with the data used for fitting effective mass plotted on top of the spectral function.","title":".plot_effective_mass"},{"location":"sources/modules/easyunfold/plotting/#plot_spectral_weights","text":". plot_spectral_weights ( figsize = ( 4 , 3 ), ylim = ( - 3 , 3 ), dpi = 150 , factor = 3.0 , eref = None , color = 'C1' , alpha = 0.5 , save = None , ax = None , show = False , title = None ) Plot the spectral weights. Note The reduction of symmetry means there can be multiple supercell kpoints for each primitive cell kpoint. When using this scattering plot representation, the markers can overlap each other leading to misrepresentations of the actual effective band structure. However, this function is still useful when: 1. the symmetry splitting is turned off. 2. direct visualization of the underlying spectral weight is needed. 3. Check the correctness of effective mass extraction. Args eref (float) : Reference energy to be used - this energy will be set as zero. figsize : Size of the figure. ylim : Plotting limit for the y-axis, with respect to eref . dpi : DPI of the generated graph. alpha (float) : Alpha for the markers. save (str) : Name of the file where the generated figure is saved. ax : Existing plotting axes to be be used (list if having two spin channels). factor (float) : Scaling factor for the marker size. color (str) : Color of the markers. Returns A Figure with the spectral weights plotted as a scatter plot.","title":".plot_spectral_weights"},{"location":"sources/modules/easyunfold/plotting/#plot_projected","text":". plot_projected ( procar , eref = None , gamma = False , npoints = 2000 , sigma = 0.2 , ncl = False , symm_average = True , figsize = ( 4 , 3 ), ylim = ( - 3 , 3 ), dpi = 150 , vscale = 1.0 , contour_plot = False , alpha = 1.0 , save = False , ax = None , vmin = None , vmax = None , cmap = 'PuRd' , show = False , title = None , atoms_idx = None , orbitals = None , intensity = 1.0 , use_subplot = False , colors = None , colorspace = 'lab' ) Plot projected sepctral function onto multiple subplots or a single plot with colormapping. This simply computes the spectral function at each orbital/atoms sites and plot them onto multiple subplots. The columns are for each orbital and the rows are for each spin channel.","title":".plot_projected"},{"location":"sources/modules/easyunfold/plotting/#interpolate_colors","text":". interpolate_colors ( colors , weights , colorspace = 'lab' , normalize = True ) Interpolate colors at a number of points within a colorspace. Args colors (str) : A list of colors specified in any way supported by matplotlib. weights (list) : A list of weights with the shape (n, N). Where the N values of the last axis give the amount of N colors supplied in colors . colorspace (str) : The colorspace in which to perform the interpolation. The allowed values are rgb, hsv, lab, luvlc, lablch, and xyz. Returns A list of colors, specified in the rgb format as a (n, 3) array.","title":"interpolate_colors"},{"location":"sources/modules/easyunfold/plotting/#process_projection_options","text":". process_projection_options ( atoms_idx , orbitals ) Process commandline type specifications","title":"process_projection_options"},{"location":"sources/modules/easyunfold/procar/","text":"Procar Procar ( fobj_or_path = None , is_soc = False ) Reader for PROCAR file Methods: .get_projection . get_projection ( atom_idx : List [ int ], proj : Union [ List [ str ], str ], weight_by_k = False ) Get project for specific atoms and specific projectors Args atom_idx (list) : A list of index of the atoms to be selected proj (list) : A list of the projector names to be selected weight_by_k : Apply k weighting or not. Returns The project summed over the selected atoms and the projectors","title":"easyunfold.procar"},{"location":"sources/modules/easyunfold/procar/#_1","text":"","title":""},{"location":"sources/modules/easyunfold/procar/#procar","text":"Procar ( fobj_or_path = None , is_soc = False ) Reader for PROCAR file Methods:","title":"Procar"},{"location":"sources/modules/easyunfold/procar/#get_projection","text":". get_projection ( atom_idx : List [ int ], proj : Union [ List [ str ], str ], weight_by_k = False ) Get project for specific atoms and specific projectors Args atom_idx (list) : A list of index of the atoms to be selected proj (list) : A list of the projector names to be selected weight_by_k : Apply k weighting or not. Returns The project summed over the selected atoms and the projectors","title":".get_projection"},{"location":"sources/modules/easyunfold/unfold/","text":"UnfoldKSet UnfoldKSet ( M , kpts_pc , pc_latt , pc_opts , sc_opts , time_reversal = True , expand = True , metadata = None , expansion_results = None , calculated_quantities = None , kpoint_labels = None ) Stores the information of the kpoints in the primitive cell, and what they unfolds to in the supercell Methods: .is_calculated . is_calculated () Show the status of the work .has_averaged_spectral_weights . has_averaged_spectral_weights () Return True if the spectral weights stored is averaged .from_atoms . from_atoms ( cls , M , kpts_pc , pc , sc , time_reversal = True , expand = True , symprec = 1e-05 ) Initialise from primitive cell and supercell atoms .expand_pc_kpoints . expand_pc_kpoints () Comptue the pc kpoints to be unfolded into .nsymm_orig . nsymm_orig () Number of symmetry operation in the original cell .nsymm_expand . nsymm_expand () Number of symmetry operation in the original cell .nkpts_orig . nkpts_orig () Total number of unexpanded kpoints .nkpts_expand . nkpts_expand () Total number of expanded kpoints .generate_sc_kpoints . generate_sc_kpoints () Generate the supercell kpoints to be calculated Returns A flat list of supercell kpoints in fractional coordinates An indexing nested list to map expanded kpoints set to the supercell kpoints generated .write_sc_kpoints . write_sc_kpoints ( file , nk_per_split = None , scf_kpoints_and_weights = None ) Write the supercell kpoints .write_pc_kpoints . write_pc_kpoints ( file , expanded = False ) Write the primitive cell kpoints .load_procar . load_procar ( procar : Union [ str , List [ str ]], force = False ) Read in PROCAR for band-based projection .procars . procars () Loaded PROCARS .procar_kmaps . procar_kmaps () Loaded PROCARS .get_band_weight_sets . get_band_weight_sets ( atoms_idx , orbitals , procars = None ) Get weights array sets for bands Construct the weights of each band in same format of the kpoint set. Each item is an numpy array of (nspins, nbands), containing the summed weights over the passed atom indices and orbitals. .get_spectral_function . get_spectral_function ( wavecar = None , npoints = 2000 , sigma = 0.1 , gamma = False , ncl = False , gamma_half = 'x' , symm_average = True , atoms_idx = None , orbitals = None ) Get the spectral function .get_spectral_weights . get_spectral_weights ( wavecar = None , gamma = False , ncl = False , gamma_half = 'x' , symm_average = True ) Get the spectral function .as_dict . as_dict () To a dictionary representation .get_kpoint_distances . get_kpoint_distances () Distances between the kpoints along the path in the reciprocal space. This does not take account of the breaking of the path. NOTE: the reciprocal lattice vectors includes the 2pi factor, e.g. np.linalg.inv(L).T * 2 * np.pi Unfold Unfold ( M = None , wavecar = 'WAVECAR' , gamma = False , lsorbit = False , gamma_half = 'x' , verbose = False ) Low lever interface for performing unfolding related calculations. obtain the effective band structure (EBS). REF: \"Extracting E versus k effective band structure from supercell calculations on alloys and impurities\" Phys. Rev. B 85, 085201 (2012) Methods: .get_vbm_cbm . get_vbm_cbm ( thresh = 1e-08 ) Locate the VBM from the WAVECAR .get_ovlap_G . get_ovlap_G ( ikpt = 1 , epsilon = 1e-05 ) Get subset of the reciprocal space vectors of the supercell, specifically the ones that match the reciprocal space vectors of the primitive cell. .find_K_index . find_K_index ( K0 ) Find the index of K0. .k2K_map . k2K_map ( kpath ) Find the map from primitive-cell k-points to supercell k-points. .spectral_weight_k . spectral_weight_k ( k0 , whichspin = 1 ) Spectral weight for a given k: P_{Km}(k) = \\sum_n | |^2 which is equivalent to P_{Km}(k) = \\sum_{G} |C_{Km}(G + k - K)|^2 where {G} is a subset of the reciprocal space vectors of the supercell. .spectral_weight . spectral_weight ( kpoints ) Calculate the spectral weight for a list of kpoints in the primitive BZ. .spectral_function . spectral_function ( nedos = 4000 , sigma = 0.02 ) Generate the spectral function A(k_i, E) = \\sum_m P_{Km}(k_i)\\Delta(E - Em) Where the \\Delta function can be approximated by Lorentzian or Gaussian function. get_symmetry_dataset . get_symmetry_dataset ( atoms , symprec = 1e-05 ) Get the symmetry dataset using spglib find_K_from_k . find_K_from_k ( k : np . ndarray , M : np . ndarray ) Get the K vector of the supercell onto which the k vector of the primitive cell folds. The unfolding vector G, which satisfy the following equation, is also returned. k = K + G where G is a reciprocal space vector of supercell rotate_kpt . rotate_kpt ( k : np . ndarray , opt : np . ndarray ) Apply rotation to a kpoint based on the rotations of the crystals (in the real space) NOTE: The rotation matrix should be the one that act on fractional coordinates, e.g. from spglib. expand_K_by_symmetry . expand_K_by_symmetry ( kpt , opts_pc , opts_sc , time_reversal = True ) Expend the sampling of the PC kpoints due to symmetry breaking of the SC LorentzSmearing . LorentzSmearing ( x , x0 , sigma = 0.02 ) Simulate the Delta function by a Lorentzian shape function \\Delta(x) = \\lim_{\\sigma\\to 0} Lorentzian GaussianSmearing . GaussianSmearing ( x , x0 , sigma = 0.02 ) Simulate the Delta function by a Lorentzian shape function \\Delta(x) = \\lim_{\\sigma\\to 0} Gaussian removeDuplicateKpoints . removeDuplicateKpoints ( kpoints , return_map = False , decimals = 6 ) remove duplicate kpoints in the list. write_kpoints . write_kpoints ( kpoints : Union [ np . ndarray , list ], outpath = 'KPOINTS' , comment = '' , weights = None ) save to VASP KPOINTS file read_kpoints . read_kpoints ( path = 'KPOINTS' ) Read kpoints from a KPOINTS file containing reciprocal space coordinates (fractional) Returns the kpoints, the comment and the labels at each kpoint read_kpoints_line . read_kpoints_line ( content , density = 20 ) Read kpoints in the line mode Resolve to explicit kpoints make_kpath . make_kpath ( kbound , nseg = 40 ) Return a list of kpoints defining the path between the given kpoints. EBS_scatter . EBS_scatter ( kpts , cell , spectral_weight , atomic_weights = None , atomic_colors = None , eref = 0.0 , nseg = None , save = 'ebs_s.png' , kpath_label = None , factor = 20 , figsize = ( 3.0 , 4.0 ), ylim = ( - 3 , 3 ), show = True , ax = None , color = 'b' ) plot the effective band structure with scatter, the size of the scatter indicates the spectral weight. The plotting function utilizes Matplotlib package. inputs: kpts: the kpoints vectors in fractional coordinates. cell: the primitive cell basis spectral_weight: self-explanatory EBS_cmaps . EBS_cmaps ( kpts , cell , E0 , spectral_function , eref = 0.0 , nseg = None , kpath_label = None , explicit_labels = None , save = None , figsize = ( 3.0 , 4.0 ), ylim = ( - 3 , 3 ), show = True , contour_plot = False , ax = None , vscale = 1.0 , title = None , vmax = None , vmin = None , alpha = 1.0 , cmap = 'jet' ) plot the effective band structure with colormaps. The plotting function utilizes Matplotlib package. Args kpts : the kpoints vectors in fractional coordinates. cell : the primitive cell basis E0 : The energies corresponds to each element of the spectral function spectral_function : The spectral function array in the shape of (nspin, nk, neng) eref : Refernce point for zero energy kpath_label : Label of the high symmetry kpoints along the pathway nseg : Number of points in each segment of the kpoint pathway explicit_labels : A list of tuplies containing tuples of (index, label) to explicitly set kpoint labels. save : Name of the file the plot to be saved to. figsize : Size of hte figure ylim : Limit for the y axis. The limit is applied after substracting the refence energy. show : To show the plot interactively or not. contour_plot : Plot in the contour mode ax : Existing axis(axes) to plot onto cmap : Colour mapping for the density/contour plot title : Title to be used vscale : Scale factor for color coding clean_latex_string . clean_latex_string ( label ) Clean up latex labels and convert if necessary spectral_function_from_weight_sets . spectral_function_from_weight_sets ( spectral_weight_sets , kweight_sets , nedos = 4000 , sigma = 0.02 , emin = None , emax = None , band_weight_sets = None ) Generate the spectral function A(k_i, E) = \\sum_m P_{Km}(k_i)\\Delta(E - Em) Where the \\Delta function can be approximated by Lorentzian or Gaussian function. Args band_weight_sets (np.ndarray) : Additional weighting for each band, used for generating projection onto atomic orbitals. spectral_weight_multiple_source . spectral_weight_multiple_source ( kpoints , unfold_objs , transform_matrix ) Calculate the spectral weight for a list of kpoints in the primitive BZ from a list of WAVECARs. concatenate_scf_kpoints . concatenate_scf_kpoints ( scf_kpts , scf_weights , kpoints ) Concatenate SCF kpoints (from IBZKPT) with zero-weighted kpoints create_white_colormap . create_white_colormap ( color : Union [ str , tuple , list ] ) Create colormap from white to certain colour. Args color (str, tuple, list) : HEX color string or tuple/list of RGB color. create_white_colormap_from_existing . create_white_colormap_from_existing ( name : str ) Create a white-based color map from an existing one. parse_atoms_idx . parse_atoms_idx ( atoms_idx ) Expanding syntex like 1-2 (inclusive) For example, 1,2,3,4-6 will be expanded as 1,2,3,4,5,6 .","title":"easyunfold.unfold"},{"location":"sources/modules/easyunfold/unfold/#_1","text":"","title":""},{"location":"sources/modules/easyunfold/unfold/#unfoldkset","text":"UnfoldKSet ( M , kpts_pc , pc_latt , pc_opts , sc_opts , time_reversal = True , expand = True , metadata = None , expansion_results = None , calculated_quantities = None , kpoint_labels = None ) Stores the information of the kpoints in the primitive cell, and what they unfolds to in the supercell Methods:","title":"UnfoldKSet"},{"location":"sources/modules/easyunfold/unfold/#is_calculated","text":". is_calculated () Show the status of the work","title":".is_calculated"},{"location":"sources/modules/easyunfold/unfold/#has_averaged_spectral_weights","text":". has_averaged_spectral_weights () Return True if the spectral weights stored is averaged","title":".has_averaged_spectral_weights"},{"location":"sources/modules/easyunfold/unfold/#from_atoms","text":". from_atoms ( cls , M , kpts_pc , pc , sc , time_reversal = True , expand = True , symprec = 1e-05 ) Initialise from primitive cell and supercell atoms","title":".from_atoms"},{"location":"sources/modules/easyunfold/unfold/#expand_pc_kpoints","text":". expand_pc_kpoints () Comptue the pc kpoints to be unfolded into","title":".expand_pc_kpoints"},{"location":"sources/modules/easyunfold/unfold/#nsymm_orig","text":". nsymm_orig () Number of symmetry operation in the original cell","title":".nsymm_orig"},{"location":"sources/modules/easyunfold/unfold/#nsymm_expand","text":". nsymm_expand () Number of symmetry operation in the original cell","title":".nsymm_expand"},{"location":"sources/modules/easyunfold/unfold/#nkpts_orig","text":". nkpts_orig () Total number of unexpanded kpoints","title":".nkpts_orig"},{"location":"sources/modules/easyunfold/unfold/#nkpts_expand","text":". nkpts_expand () Total number of expanded kpoints","title":".nkpts_expand"},{"location":"sources/modules/easyunfold/unfold/#generate_sc_kpoints","text":". generate_sc_kpoints () Generate the supercell kpoints to be calculated Returns A flat list of supercell kpoints in fractional coordinates An indexing nested list to map expanded kpoints set to the supercell kpoints generated","title":".generate_sc_kpoints"},{"location":"sources/modules/easyunfold/unfold/#write_sc_kpoints","text":". write_sc_kpoints ( file , nk_per_split = None , scf_kpoints_and_weights = None ) Write the supercell kpoints","title":".write_sc_kpoints"},{"location":"sources/modules/easyunfold/unfold/#write_pc_kpoints","text":". write_pc_kpoints ( file , expanded = False ) Write the primitive cell kpoints","title":".write_pc_kpoints"},{"location":"sources/modules/easyunfold/unfold/#load_procar","text":". load_procar ( procar : Union [ str , List [ str ]], force = False ) Read in PROCAR for band-based projection","title":".load_procar"},{"location":"sources/modules/easyunfold/unfold/#procars","text":". procars () Loaded PROCARS","title":".procars"},{"location":"sources/modules/easyunfold/unfold/#procar_kmaps","text":". procar_kmaps () Loaded PROCARS","title":".procar_kmaps"},{"location":"sources/modules/easyunfold/unfold/#get_band_weight_sets","text":". get_band_weight_sets ( atoms_idx , orbitals , procars = None ) Get weights array sets for bands Construct the weights of each band in same format of the kpoint set. Each item is an numpy array of (nspins, nbands), containing the summed weights over the passed atom indices and orbitals.","title":".get_band_weight_sets"},{"location":"sources/modules/easyunfold/unfold/#get_spectral_function","text":". get_spectral_function ( wavecar = None , npoints = 2000 , sigma = 0.1 , gamma = False , ncl = False , gamma_half = 'x' , symm_average = True , atoms_idx = None , orbitals = None ) Get the spectral function","title":".get_spectral_function"},{"location":"sources/modules/easyunfold/unfold/#get_spectral_weights","text":". get_spectral_weights ( wavecar = None , gamma = False , ncl = False , gamma_half = 'x' , symm_average = True ) Get the spectral function","title":".get_spectral_weights"},{"location":"sources/modules/easyunfold/unfold/#as_dict","text":". as_dict () To a dictionary representation","title":".as_dict"},{"location":"sources/modules/easyunfold/unfold/#get_kpoint_distances","text":". get_kpoint_distances () Distances between the kpoints along the path in the reciprocal space. This does not take account of the breaking of the path. NOTE: the reciprocal lattice vectors includes the 2pi factor, e.g. np.linalg.inv(L).T * 2 * np.pi","title":".get_kpoint_distances"},{"location":"sources/modules/easyunfold/unfold/#unfold","text":"Unfold ( M = None , wavecar = 'WAVECAR' , gamma = False , lsorbit = False , gamma_half = 'x' , verbose = False ) Low lever interface for performing unfolding related calculations. obtain the effective band structure (EBS). REF: \"Extracting E versus k effective band structure from supercell calculations on alloys and impurities\" Phys. Rev. B 85, 085201 (2012) Methods:","title":"Unfold"},{"location":"sources/modules/easyunfold/unfold/#get_vbm_cbm","text":". get_vbm_cbm ( thresh = 1e-08 ) Locate the VBM from the WAVECAR","title":".get_vbm_cbm"},{"location":"sources/modules/easyunfold/unfold/#get_ovlap_g","text":". get_ovlap_G ( ikpt = 1 , epsilon = 1e-05 ) Get subset of the reciprocal space vectors of the supercell, specifically the ones that match the reciprocal space vectors of the primitive cell.","title":".get_ovlap_G"},{"location":"sources/modules/easyunfold/unfold/#find_k_index","text":". find_K_index ( K0 ) Find the index of K0.","title":".find_K_index"},{"location":"sources/modules/easyunfold/unfold/#k2k_map","text":". k2K_map ( kpath ) Find the map from primitive-cell k-points to supercell k-points.","title":".k2K_map"},{"location":"sources/modules/easyunfold/unfold/#spectral_weight_k","text":". spectral_weight_k ( k0 , whichspin = 1 ) Spectral weight for a given k: P_{Km}(k) = \\sum_n | |^2 which is equivalent to P_{Km}(k) = \\sum_{G} |C_{Km}(G + k - K)|^2 where {G} is a subset of the reciprocal space vectors of the supercell.","title":".spectral_weight_k"},{"location":"sources/modules/easyunfold/unfold/#spectral_weight","text":". spectral_weight ( kpoints ) Calculate the spectral weight for a list of kpoints in the primitive BZ.","title":".spectral_weight"},{"location":"sources/modules/easyunfold/unfold/#spectral_function","text":". spectral_function ( nedos = 4000 , sigma = 0.02 ) Generate the spectral function A(k_i, E) = \\sum_m P_{Km}(k_i)\\Delta(E - Em) Where the \\Delta function can be approximated by Lorentzian or Gaussian function.","title":".spectral_function"},{"location":"sources/modules/easyunfold/unfold/#get_symmetry_dataset","text":". get_symmetry_dataset ( atoms , symprec = 1e-05 ) Get the symmetry dataset using spglib","title":"get_symmetry_dataset"},{"location":"sources/modules/easyunfold/unfold/#find_k_from_k","text":". find_K_from_k ( k : np . ndarray , M : np . ndarray ) Get the K vector of the supercell onto which the k vector of the primitive cell folds. The unfolding vector G, which satisfy the following equation, is also returned. k = K + G where G is a reciprocal space vector of supercell","title":"find_K_from_k"},{"location":"sources/modules/easyunfold/unfold/#rotate_kpt","text":". rotate_kpt ( k : np . ndarray , opt : np . ndarray ) Apply rotation to a kpoint based on the rotations of the crystals (in the real space) NOTE: The rotation matrix should be the one that act on fractional coordinates, e.g. from spglib.","title":"rotate_kpt"},{"location":"sources/modules/easyunfold/unfold/#expand_k_by_symmetry","text":". expand_K_by_symmetry ( kpt , opts_pc , opts_sc , time_reversal = True ) Expend the sampling of the PC kpoints due to symmetry breaking of the SC","title":"expand_K_by_symmetry"},{"location":"sources/modules/easyunfold/unfold/#lorentzsmearing","text":". LorentzSmearing ( x , x0 , sigma = 0.02 ) Simulate the Delta function by a Lorentzian shape function \\Delta(x) = \\lim_{\\sigma\\to 0} Lorentzian","title":"LorentzSmearing"},{"location":"sources/modules/easyunfold/unfold/#gaussiansmearing","text":". GaussianSmearing ( x , x0 , sigma = 0.02 ) Simulate the Delta function by a Lorentzian shape function \\Delta(x) = \\lim_{\\sigma\\to 0} Gaussian","title":"GaussianSmearing"},{"location":"sources/modules/easyunfold/unfold/#removeduplicatekpoints","text":". removeDuplicateKpoints ( kpoints , return_map = False , decimals = 6 ) remove duplicate kpoints in the list.","title":"removeDuplicateKpoints"},{"location":"sources/modules/easyunfold/unfold/#write_kpoints","text":". write_kpoints ( kpoints : Union [ np . ndarray , list ], outpath = 'KPOINTS' , comment = '' , weights = None ) save to VASP KPOINTS file","title":"write_kpoints"},{"location":"sources/modules/easyunfold/unfold/#read_kpoints","text":". read_kpoints ( path = 'KPOINTS' ) Read kpoints from a KPOINTS file containing reciprocal space coordinates (fractional) Returns the kpoints, the comment and the labels at each kpoint","title":"read_kpoints"},{"location":"sources/modules/easyunfold/unfold/#read_kpoints_line","text":". read_kpoints_line ( content , density = 20 ) Read kpoints in the line mode Resolve to explicit kpoints","title":"read_kpoints_line"},{"location":"sources/modules/easyunfold/unfold/#make_kpath","text":". make_kpath ( kbound , nseg = 40 ) Return a list of kpoints defining the path between the given kpoints.","title":"make_kpath"},{"location":"sources/modules/easyunfold/unfold/#ebs_scatter","text":". EBS_scatter ( kpts , cell , spectral_weight , atomic_weights = None , atomic_colors = None , eref = 0.0 , nseg = None , save = 'ebs_s.png' , kpath_label = None , factor = 20 , figsize = ( 3.0 , 4.0 ), ylim = ( - 3 , 3 ), show = True , ax = None , color = 'b' ) plot the effective band structure with scatter, the size of the scatter indicates the spectral weight. The plotting function utilizes Matplotlib package. inputs: kpts: the kpoints vectors in fractional coordinates. cell: the primitive cell basis spectral_weight: self-explanatory","title":"EBS_scatter"},{"location":"sources/modules/easyunfold/unfold/#ebs_cmaps","text":". EBS_cmaps ( kpts , cell , E0 , spectral_function , eref = 0.0 , nseg = None , kpath_label = None , explicit_labels = None , save = None , figsize = ( 3.0 , 4.0 ), ylim = ( - 3 , 3 ), show = True , contour_plot = False , ax = None , vscale = 1.0 , title = None , vmax = None , vmin = None , alpha = 1.0 , cmap = 'jet' ) plot the effective band structure with colormaps. The plotting function utilizes Matplotlib package. Args kpts : the kpoints vectors in fractional coordinates. cell : the primitive cell basis E0 : The energies corresponds to each element of the spectral function spectral_function : The spectral function array in the shape of (nspin, nk, neng) eref : Refernce point for zero energy kpath_label : Label of the high symmetry kpoints along the pathway nseg : Number of points in each segment of the kpoint pathway explicit_labels : A list of tuplies containing tuples of (index, label) to explicitly set kpoint labels. save : Name of the file the plot to be saved to. figsize : Size of hte figure ylim : Limit for the y axis. The limit is applied after substracting the refence energy. show : To show the plot interactively or not. contour_plot : Plot in the contour mode ax : Existing axis(axes) to plot onto cmap : Colour mapping for the density/contour plot title : Title to be used vscale : Scale factor for color coding","title":"EBS_cmaps"},{"location":"sources/modules/easyunfold/unfold/#clean_latex_string","text":". clean_latex_string ( label ) Clean up latex labels and convert if necessary","title":"clean_latex_string"},{"location":"sources/modules/easyunfold/unfold/#spectral_function_from_weight_sets","text":". spectral_function_from_weight_sets ( spectral_weight_sets , kweight_sets , nedos = 4000 , sigma = 0.02 , emin = None , emax = None , band_weight_sets = None ) Generate the spectral function A(k_i, E) = \\sum_m P_{Km}(k_i)\\Delta(E - Em) Where the \\Delta function can be approximated by Lorentzian or Gaussian function. Args band_weight_sets (np.ndarray) : Additional weighting for each band, used for generating projection onto atomic orbitals.","title":"spectral_function_from_weight_sets"},{"location":"sources/modules/easyunfold/unfold/#spectral_weight_multiple_source","text":". spectral_weight_multiple_source ( kpoints , unfold_objs , transform_matrix ) Calculate the spectral weight for a list of kpoints in the primitive BZ from a list of WAVECARs.","title":"spectral_weight_multiple_source"},{"location":"sources/modules/easyunfold/unfold/#concatenate_scf_kpoints","text":". concatenate_scf_kpoints ( scf_kpts , scf_weights , kpoints ) Concatenate SCF kpoints (from IBZKPT) with zero-weighted kpoints","title":"concatenate_scf_kpoints"},{"location":"sources/modules/easyunfold/unfold/#create_white_colormap","text":". create_white_colormap ( color : Union [ str , tuple , list ] ) Create colormap from white to certain colour. Args color (str, tuple, list) : HEX color string or tuple/list of RGB color.","title":"create_white_colormap"},{"location":"sources/modules/easyunfold/unfold/#create_white_colormap_from_existing","text":". create_white_colormap_from_existing ( name : str ) Create a white-based color map from an existing one.","title":"create_white_colormap_from_existing"},{"location":"sources/modules/easyunfold/unfold/#parse_atoms_idx","text":". parse_atoms_idx ( atoms_idx ) Expanding syntex like 1-2 (inclusive) For example, 1,2,3,4-6 will be expanded as 1,2,3,4,5,6 .","title":"parse_atoms_idx"},{"location":"sources/modules/easyunfold/wavecar/","text":"Wavecar Wavecar ( fnm = 'WAVECAR' , lsorbit = False , lgamma = False , gamma_half = 'x' , omp_num_threads = 1 ) Class for processing VASP Pseudowavefunction stored in WAVECAR. This class is a trimmed-down from that of PyVaspwfc by QijingZheng zqj.kaka@gmail.com . Only the functions needed for band unfolding remains. The original class has many other functionalities such as ELF calculation. The format of VASP WAVECAR, as shown in http://www.andrew.cmu.edu/user/feenstra/wavetrans/ is: Record-length #spin components RTAG(a value specifying the precision) #k-points #bands ENCUT(maximum energy for plane waves) LatVec-A LatVec-B LatVec-C Loop over spin Loop over k-points #plane waves, k vector Loop over bands band energy, band occupation End loop over bands Loop over bands Loop over plane waves Plane-wave coefficient End loop over plane waves End loop over bands End loop over k-points End loop over spin Methods: .isSocWfc . isSocWfc () Is the WAVECAR from an SOC calculation? .isGammaWfc . isGammaWfc () Is the WAVECAR from an SOC calculation? .readWFHeader . readWFHeader () Read the system information from WAVECAR, which is written in the first two record. rec1: recl, nspin, rtag rec2: nkpts, nbands, encut, ((cell(i,j) i=1, 3), j=1, 3) .setWFPrec . setWFPrec () Set wavefunction coefficients precision: TAG = 45200: single precision complex, np.complex64, or complex(qs) TAG = 45210: double precision complex, np.complex128, or complex(q) .readWFBand . readWFBand () Extract KS energies and Fermi occupations from WAVECAR. .gvectors . gvectors ( ikpt = 1 , force_Gamma = False , check_consistency = True ) Generate the G-vectors that satisfies the following relation (G + k)**2 / 2 < ENCUT .readBandCoeff . readBandCoeff ( ispin = 1 , ikpt = 1 , iband = 1 , norm = False ) Read the planewave coefficients of specified KS states. .whereRec . whereRec ( ispin = 1 , ikpt = 1 , iband = 1 ) Return the rec position for specified KS state. .checkIndex . checkIndex ( ispin , ikpt , iband ) Check if the index is valid!","title":"easyunfold.wavecar"},{"location":"sources/modules/easyunfold/wavecar/#_1","text":"","title":""},{"location":"sources/modules/easyunfold/wavecar/#wavecar","text":"Wavecar ( fnm = 'WAVECAR' , lsorbit = False , lgamma = False , gamma_half = 'x' , omp_num_threads = 1 ) Class for processing VASP Pseudowavefunction stored in WAVECAR. This class is a trimmed-down from that of PyVaspwfc by QijingZheng zqj.kaka@gmail.com . Only the functions needed for band unfolding remains. The original class has many other functionalities such as ELF calculation. The format of VASP WAVECAR, as shown in http://www.andrew.cmu.edu/user/feenstra/wavetrans/ is: Record-length #spin components RTAG(a value specifying the precision) #k-points #bands ENCUT(maximum energy for plane waves) LatVec-A LatVec-B LatVec-C Loop over spin Loop over k-points #plane waves, k vector Loop over bands band energy, band occupation End loop over bands Loop over bands Loop over plane waves Plane-wave coefficient End loop over plane waves End loop over bands End loop over k-points End loop over spin Methods:","title":"Wavecar"},{"location":"sources/modules/easyunfold/wavecar/#issocwfc","text":". isSocWfc () Is the WAVECAR from an SOC calculation?","title":".isSocWfc"},{"location":"sources/modules/easyunfold/wavecar/#isgammawfc","text":". isGammaWfc () Is the WAVECAR from an SOC calculation?","title":".isGammaWfc"},{"location":"sources/modules/easyunfold/wavecar/#readwfheader","text":". readWFHeader () Read the system information from WAVECAR, which is written in the first two record. rec1: recl, nspin, rtag rec2: nkpts, nbands, encut, ((cell(i,j) i=1, 3), j=1, 3)","title":".readWFHeader"},{"location":"sources/modules/easyunfold/wavecar/#setwfprec","text":". setWFPrec () Set wavefunction coefficients precision: TAG = 45200: single precision complex, np.complex64, or complex(qs) TAG = 45210: double precision complex, np.complex128, or complex(q)","title":".setWFPrec"},{"location":"sources/modules/easyunfold/wavecar/#readwfband","text":". readWFBand () Extract KS energies and Fermi occupations from WAVECAR.","title":".readWFBand"},{"location":"sources/modules/easyunfold/wavecar/#gvectors","text":". gvectors ( ikpt = 1 , force_Gamma = False , check_consistency = True ) Generate the G-vectors that satisfies the following relation (G + k)**2 / 2 < ENCUT","title":".gvectors"},{"location":"sources/modules/easyunfold/wavecar/#readbandcoeff","text":". readBandCoeff ( ispin = 1 , ikpt = 1 , iband = 1 , norm = False ) Read the planewave coefficients of specified KS states.","title":".readBandCoeff"},{"location":"sources/modules/easyunfold/wavecar/#whererec","text":". whereRec ( ispin = 1 , ikpt = 1 , iband = 1 ) Return the rec position for specified KS state.","title":".whereRec"},{"location":"sources/modules/easyunfold/wavecar/#checkindex","text":". checkIndex ( ispin , ikpt , iband ) Check if the index is valid!","title":".checkIndex"}]}